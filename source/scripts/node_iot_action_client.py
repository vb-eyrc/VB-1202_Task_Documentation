#!/usr/bin/env python

"""
Action Client for the ROS IoT bridge, to receive and send requests and data to and from
the MQTT server.
"""

import json
import rospy
import actionlib

from pkg_ros_iot_bridge.msg import msgRosIotAction
from pkg_ros_iot_bridge.msg import msgRosIotGoal
from pkg_ros_iot_bridge.msg import msgRosIotResult


class RosIotBridgeActionClient(object):
    """
    Class for the module.
    """
    def __init__(self):
        """
        Constructor containing essential data.
        """

        # Initialize Action Client
        self._ac = actionlib.ActionClient('/action_ros_iot',
                                          msgRosIotAction)

        # Dictionary to Store all the goal handles
        self._goal_handles = {}

        # Store the MQTT Topic on which to Publish in a variable
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']

        # Wait for Action Server that will use the action - '/action_ros_iot' to start
        self._ac.wait_for_server()
        rospy.loginfo("Action server up, we can send goals.")

    def on_transition(self, goal_handle):
        """
        .. autometh: on_transition
        
        This function will be called when there is a
        change of state in the Action Client State Machine

        :param dict goal_handle: The goal to be sent to the server.
        """

        # from on_goal() to on_transition(). goal_handle generated by send_goal() is used here.

        msgRosIotResult()

        index = 0
        for i in self._goal_handles:
            if self._goal_handles[i] == goal_handle:
                index = i
                break

        rospy.loginfo("Transition Callback. Client Goal Handle #: " + str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()))
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()))

        # Comm State - Monitors the State Machine of the Client which is different from Server's
        # Comm State = 2 -> Active
        # Comm State = 3 -> Waiting for Result
        # Comm State = 7 -> Done

        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")

        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())

            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)

            if result.flag_success:
                rospy.loginfo("Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " + str(index))


    def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message):
        """
        # This function is used to send Goals to Action Server

        :param arg_protocol:
        :param arg_mode:
        :param arg_topic:
        :param arg_message:
        :return: The goal handle.
        :rtype: dict
        """

        # Create a Goal Message object
        goal = msgRosIotGoal()

        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message

        rospy.loginfo("Send goal.")

        # self.on_transition - It is a function pointer to a function which will be called when
        #                       there is a change of state in the Action Client State Machine
        goal_handle = self._ac.send_goal(goal,
                                         self.on_transition,
                                         None)
        return goal_handle

    def send_goal_pls(self, dictionary):
        """
        Parameterized Dictionaries are sent to spreadsheet push
        :param dictionary:
        :return:
        """

        goal_res = json.dumps(dictionary, default=str)
        goal_handle = self.send_goal("mqtt", "pub", self._config_mqtt_pub_topic, goal_res)
        self._goal_handles['1'] = goal_handle
        rospy.sleep(0.4)
        goal_handle.cancel()
